---
title: "复习题-机器视觉识别"
published: 2025-12-26
description: "机器视觉识别课程的复习题集，包含单选题、多选题和编程题"
category: "复习资料"
tags: ["机器视觉", "OpenCV", "图像处理", "复习"]
---

## 一、单选题

1. 使用cv2.imread(*img, flags*)读取图片时，关于其说法错误的是 :spoiler[**答案：C**] )

   A. flags值可以是-1或0

   B. flags值可以是1或2

   C. 如果不设置flags值，默认是以灰度图像加载图片
   
   D. 如果flags设置值是0，返回图像的灰度图



2. 对于数字图像点位置（x，y），位置（x-1，y）、（x+1，y）、（x，y+1）、（x，y-1）的像素灰度值分别是20、23、100、104，则其梯度值是 :spoiler[**答案：A**] )

   A. 6                                 B. 5
   
   C. 4                                 D. 3

3. 关于CV2.rectangle绘制矩形描述错误的是 :spoiler[**答案：C**] )

   A. 可以使用rectangle(img, pt1,pt2,color)绘制矩形，img表示源图，pt1表示矩形顶点坐标，pt2表示矩形另一个顶点坐标，color表示线条颜色
   
   B. 可以使用rectangle(img, rect,color)绘制矩形，img表示源图，rect是表示矩形左上角坐标、宽度、高度的四元组，color表示线条颜色
   
   C. 绘制矩形函数rectangle需要指定矩形的线条颜色
   
   D. 绘制矩形函数rectangle不需要指定矩形的线条颜色

4. 自适应阈值分割与固定阈值的全局分割不同，而是根据图像不同区域亮度分布计算局部阈值，对图像各个部分进行分割，一般不采用（）来确定阈值 :spoiler[**答案：D**] )

   A. 均值                              B. 中值
   
   C. 高斯加权                              D. 最大值

5. Opencv中getStructuringElement函数获取结构元，关于该函数描述不正确的是（） :spoiler[**答案：A**] )

   A. 可以不指定结构元大小
   
   B. 可以指定结构元是十字形
   
   C. 可以指定结构元大小
   
   D. 可以指定结构元是矩形

6. 以下关于机器学习算法描述不正确的是 :spoiler[**答案：C**] )

   A. 机器学习算法可以分为监督学习、无监督学习和强化学习三类
   
   B. 监督学习是通过已标记的训练数据来训练模型
   
   C. 无监督学习是通过已标记的训练数据来训练模型，以达到最大化累积奖励的目标
   
   D. 机器学习广泛应用于图像识别、自然语言处理和推荐系统等领域

7. 关于OpenCV的仿射变换函数WarpAffine(src,M,dsize)描述错误的是 :spoiler[**答案：B**] )

   A. M表示用于变换的矩阵
   
   B. 如果矩阵M=numpy.float32([[1,0,100],[0,1,50]])表示对图像进行旋转
   
   C. 如果矩阵M=numpy.float32([[2,0,0],[0,2,0]])表示对图像进行放大
   
   D. 如果矩阵M=numpy.float32([[0.5,0,0],[0,0.5,0]])表示对图像进行缩小

8. 以下关于OpenCV颜色变换函数cvtColor的相关命令描述错误的是 :spoiler[**答案：D**] )

   A. cv2.COLOR_BGR2GRAY参数是把src_image转换为灰色图
   
   B. cv2.COLOR_BGR2HSV参数是把src_image转换为HSV颜色图
   
   C. cv2.COLOR_BGR2YCrCb参数是把src_image转换为YUV颜色图
   
   D. cv2.COLOR_BGR2GRAY参数是把src_image转换为二值图

9. 常用的图像分类算法不包含以下哪项（） :spoiler[**答案：A**] )

   A. sift特征检测算法
   
   B. SVM分类算法
   
   C. 卷积神经网络算法
   
   D. KNN分类算法

10. 以下关于图像滤波各种方法描述错误的是 :spoiler[**答案：D**] )

   A. 高斯滤波对于抑制图像服从正态分布的噪声有较好的效果

   B. OpenCV高斯滤波函数是GaussianBlur

   C. 中值滤波对于除去斑点噪声和椒盐噪声很有用

   D. 双边滤波去除噪声的同时不能够保留轮廓的清晰度

11. OpenCV读取视频VideoCapture(args)类传入参数描述错误的是 :spoiler[**答案：B**] )

   A. args可以是视频文件路径，表示读取本地视频

   B. args可以是摄像头编号，表示读取本地视频

   C. retval, image = cv2.VideoCapture.read()表示抓取视频帧，retval为TRUE时表示抓取成功

   D. retval = cv2.VideoCapture.isOpened()用于判断视频是否成功打开



12. 以下关于torch读取自定义数据集说法不正确的是 :spoiler[**答案：D**] )

   A. 需要添加依赖from torch.utils.data import Dataset

   B. 自定义数据集读取类需要重写__len__(self)函数

   C. 自定义数据集读取类需要重写__getitem__(self, idx)函数

   D. 继承Dataset的变量image_paths和labels是整数数组类型

13. 以下哪一项不是SVM（支持向量机）的相关概念描述 :spoiler[**答案：B**] )

   A. 最大间隔分类器：能够将不同类别的样本点以最大间隔分开的超平面

   B. 权值共享：与图像进行局部连接的所有神经元使用同一组参数，即一个特征平面使用同一个卷积核内的参数

   C. 核函数是将原始特征映射到高维特征空间，从而使得非线性问题在高维空间中变为线性可分的问题

   D. 松弛变量用于衡量每个样本对于分类超平面的违背程度

14. 以下关于OpenCV图像滤波函数描述正确的是 :spoiler[**答案：C**] )

   A. OpenCV双边滤波使用函数GaussianBlur

   B. OpenCV高斯滤波使用函数medianBlur

   C. OpenCV双边滤波使用函数bilateralFilter

   D. OpenCV滤波函数一般需要输入原图像、滤波核大小以及边界类型

15. 图像仿射变换一般不包括以下哪种 :spoiler[**答案：D**] )

   A. 平移

   B. 缩放

   C. 旋转

   D. 平滑

16. 关于卷积神经网络以下说法正确的是 :spoiler[**答案：C**] )

   A. 池化过程是用卷积核按照一定步长输入矩阵进行点积运算，将卷积结果输入激活函数得到矩阵称为特征图

   B. 卷积操作将语义上相似的特征合并起来，常取对应区域的最大值、平均值等

   C. LeNet-5和Alexnet都是卷积神经网络

   D. 为了快速调整卷积神经网络的参数，一般选择较大的学习率

17. 关于目标检测模型YOLO说法正确的是 :spoiler[**答案：B**] )

   A. 目前YOLOv6是最新版本

   B. YOLO模型训练可以根据实际自定义目标类别

   C. YOLO模型训练必须编写自定义数据集读取类

   D. YOLO模型包含大量的卷积层、池化层、隐藏层

18. OpenCV中固定阈值化函数声明threshold(src, thresh, maxval, type[, dst])，关于其说法正确的是 :spoiler[**答案：A**] )

   A. src为输入图像，thresh表示阈值

   B. type如果取值cv2.THRESH_TRUNC则超过阈值部分取255，否则取0

   C. type如果取值cv2. THRESH_BINARY则大于阈值部分设为阈值，否则不变

   D. type如果取值cv2.THRESH_OTSU则大于阈值部分设为0，小于部分不改变

19. 关于图像灰度直方图的描述正确的是 :spoiler[**答案：B**] )

   A. 对直方图进行均衡化时可以现将图像从YUV空间转换为RGB空间，再对图像三个通道分别进行均衡化 

   B. OpenCV的灰度直方图计算函数是calcHist，直方图均衡化是增强图像对比度的方法

   C. 对直方图进行均衡化时可以现将图像从YUV空间转换为BGR空间，再对图像三个通道分别进行均衡化 

   D. OpenCV的直方图均衡化函数是calcHist，灰度直方图计算函数是equalizeHist

20. train_test_split是scikit-learn中一个常用的函数，用于将数据集划分为训练集和测试集，以便于模型的训练和评估。其使用方法如下示例：

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

关于以上代码说法错误的是 :spoiler[**答案：D**] )

   A. 输入值X是特征矩阵

   B. 输入值y一般是特征对应的标签值矩阵

   C. 输入值test_size参数指定了测试集所占的比例，可以是一个小数（表示比例）或整数（表示样本数量）

   D. 输入值random_state要求每次必须是同一个值

21. 关于代码img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)说法错误的是 :spoiler[**答案：B**] )

   A. 该代码用于将目标图像灰度化

   B. cv2.COLOR_BGR2GRAY不是常量值

   C. 输入值img具有三个颜色通道

   D. 返回值img是一个二维数组，数组中每个值都是一个不大于255的整数

22. 关于代码knn = cv2.ml.KNearest.create()说法正确的是 :spoiler[**答案：C**] )

   A. 调用opencv的ml类初始化knn模型

   B. 通过该代码可知KNearest是opencv的ml模块中的一个接口函数

   C. 调用opencv的KNearest类初始化方法创建knn模型实例

   D. 通过该代码可知不同版本的opencv都是使用create()函数创建knn模型实例

23. OpenCV常见的图像平滑技术不包括以下哪个 :spoiler[**答案：D**] )

   A. 平均滤波 

   B. 高斯滤波

   C. 中值滤波

   D. 直方图均衡化

24. 关于均值滤波描述正确的是 :spoiler[**答案：C**] )

   A. 均值滤波使用函数blur(src,ksize,anchor,boderType)，其中anchor是指滤波核大小

   B. 均值滤波不会模糊图像轮廓

   C. 均值滤波使用函数blur(src,ksize,anchor,boderType)，滤波核越大滤波后图像越模糊

   D. 均值滤波使用函数blur(src,ksize,anchor,boderType)，滤波核越小滤波后图像越模糊

25. 对于数字图像点位置（x0，y0），位置（x-1，y）、（x+1，y）、（x，y+1）、（x，y-1）的像素灰度值分别是40、43、200、204，则（x0，y0）处梯度值是 :spoiler[**答案：B**] )

   A. 5                              B. 6

   C.  3                              D. 4

26. 在OpenCV中，固定阈值化函数为threshold，函数声明如下： threshold(src, thresh, maxval, type[, dst]) → retval，关于其说法错误的是 :spoiler[**答案：D**] )

   A. src为输入图像，thresh表示阈值

   B. type表示阈值化类型，如果取值cv2.THRESH_BINARY则超过阈值部分取255，否则取0

   C. type表示阈值化类型，如果取值cv2.THRESH_TRUNC则大于阈值部分设为阈值，否则不变

   D. type表示阈值化类型，如果取值cv2.THRESH_OTSU则大于阈值部分设为0，小于部分不改变



27. 以下关于图像特征说法错误的是 :spoiler[**答案：C**] )

   A. 拐点被认为是图像中的良好特征

   B. 在某些情况下，斑点也被认为是不错的特征

   C. 哈里斯角点具有旋转不变性和尺度（缩放）不变性

   D. 方向梯度直方图HOG特征通过计算和统计图像局部区域的梯度方向直方图来构成特征

28. KNN（K最近邻算法）常用于图像分类和目标识别任务，关于其说法正确的是 :spoiler[**答案：A**] )

   A. KNN是非参数学习算法，无显式训练过程

   B. KNN是参数学习算法，有显式训练过程

   C. KNN模型的训练就是特征提取

   D. KNN模型对于输入特征长度有绝对要求

29. 关于图像灰度直方图的描述错误的是 :spoiler[**答案：B**] )

   A. OpenCV的灰度直方图计算函数是calcHist

   B. 对直方图进行均衡化时可以现将图像从YUV空间转换为RGB空间，再对图像三个通道分别进行均衡化 

   C. OpenCV的直方图均衡化函数是equalizeHist

   D. 直方图均衡化是增强图像对比度的方法

30. 对于图像线性变换方法描述正确的是 :spoiler[**答案：D**] )

   A. 灰度线性变换可以将原图像灰度动态范围按线性关系扩展到指定范围，但是不可以缩小灰度范围

   B. 分段线性变换可以对感兴趣的灰度区间增强，参数选择必须手动选择

   C. 对数变换使用函数的numpy的pow函数

   D. 对数变换使用函数的numpy的log函数

31. SVC（Support Vector Classifier）是一种支持向量机分类器，能够对数据进行分类和预测。以下关于其描述错误的是 :spoiler[**答案：D**] )

   A. 导入sklearn中的SVC可以使用from sklearn.svm import SVC代码

   B. 创建svc分类器可以使用代码svc = SVC(kernel='rbf', C=1.0)

   C. 训练svc分类器可以使用代码svc.fit(X_train, y_train)，其中X_train是训练特征，y_train是特征标签值

   D. 测试svc分类器可以使用代码y_pred = svc.predict(X_test)，其中X_test是测试标签



32. 关于图像金字塔模型以下说法正确的是（） :spoiler[**答案：B**] )

   A. 高斯金字塔只对图像简单降采样，没有加上滤波

   B. 图像向上取样是由小图像不断放大图像的过程，OpenCV函数是pyrUp(src, dst = None, dstsize = None, borderType = None)

   C. 拉普拉斯金字塔是通过源图像先缩小后再放大的图像的一系列图像构成的

   D. OpenCV下采样函数pyrDown(src, dst = None, dstsize = None, borderType = None)，其中dstSize指的是原图大小

33. LeNet是一个卷积神经网络，如果使用torch构建该模型，则以下说法不正确的是 :spoiler[**答案：C**] )

   A. 需要继承torch.nn.Module类

   B. 卷积层定义可以使用torch.nn.Conv2d类

   C. 全连接层定义可以使用torch.nn.Linear2d类

   D. 池化层定义可以使用 torch.nn.MaxPool2d类

34. Canny边缘检测是一种流行的边缘检测算法，关于其说法正确的是（） :spoiler[**答案：B**] )

   A. 使用canny算法前，可以不用高斯滤波平滑图像。

   B. OpenCV中实现Canny算法的函数是 Canny(InputArray image, double threshold1,double threshold2,OutputArray edges=None, int apertureSize=None,bool L2gradient=None) ，其中参数Image是输入图像，单通道为8bit； Threshold1是第一个滞后性阈值； Threshold2是第二个滞后性阈值

   C. canny算法使用非极大值抑制，对伪边界点增强

   D. canny算法使用非极大值增强，对伪边界点抑制

35. 使用torch创建卷积网络时，关于前向传播函数forward（self, x）说法不正确的是 :spoiler[**答案：A**] )

   A. 前向传播和反向传播一样，都是用来更新网络的参数

   B. 前向传播的主要任务是根据输入数据计算神经网络的输出

   C. 神经网络训练完成后，前向传播函数用于进行推理，即给定一个输入，网络通过前向传播计算出预测结果

   D. 前向传播计算出的输出还会与实际标签对比，计算损失函数，然后用于反向传播来更新网络的参数

36. 以下关于图像特征描述不正确的是？ :spoiler[**答案：D**] )

   A. 哈里斯角点的具有旋转不变性

   B. 方向梯度直方图特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述方法，通过计算和统计图像局部区域的梯度方向直方图来构成特征。

   C. SIFT特征具有尺度不变性

   D. 哈里斯角点的具有尺度不变性

37. OpenCV读取视频VideoCapture(args)类说法正确的是 :spoiler[**答案：A**] )

   A. args如果取0，表示读取摄像头编号0的图像

   B. args如果取0，表示读取本地视频

   C. args如果取视频文件路径，表示读读取摄像头编号0的图像

   D. retval = cv2.VideoCapture.isOpened()如果返回FALSE表示视频成功打开

38. 以下哪项不是机器学习图像分类算法 :spoiler[**答案：C**] )

   A. K-Means聚类算法

   B. SVM分类算法

   C. 线性变换分类算法

   D. KNN分类算法

39. 使用OpenCV做图像数据集增强通常不包括以下哪种方法 :spoiler[**答案：C**] )

   A. 旋转、翻转

   B. 平移、缩放

   C. 随机删除、模糊化

   D. 对比度调整、饱和度调整

40. 以下关于卷积神经网络说法错误的是 :spoiler[**答案：D**] )

   A. 卷积操作主要是为了得到不同的特征图和减少权值数量

   B. 池化层主要作用是下采样

   C. 归一化是将不同范围的值映射到相同的固定范围中，减小样本间的差异

   D. 使用随机梯度下降（SGD）算法比使用小批量梯度下降（MBGD）算法效果更好

 

## 二、多选题

1. cv2.morphologyEx(src, op, kernel)函数是对图像进行各类形态学变化操作，关于op参数描述正确的有 :spoiler[**答案：ABCD**] )

   A. op = cv2.MORPH_GRADIENT 梯度操作，可以获取图像的边缘
   
   B. op = cv2.MORPH_TOPHAT 顶帽操作，可以分离亮斑，提取图像的背景
   
   C. op = cv2.MORPH_BLACKHAT 黑帽操作，可以分离暗斑，提取图像的背景
   
   D. op = cv2.MORPH_OPEN 进行开运算，可以去除背景噪声

2. 常用的机器学习算法包括哪些？ :spoiler[**答案：ABCD**] )

   A. 支持向量机（SVM）
   
   B. K最近邻（KNN）
   
   C. 卷积神经网络（CNN）
   
   D. 决策树和随机森林

3. 关于OpenCV图像边缘检测算子说法正确有 :spoiler[**答案：ABCD**] )

   A. Roberts算子的模板分为水平方向和垂直方向，能较好的增强正负45度的图像边缘
   
   B. Sobel算子（索贝尔算子）是一种用于边缘检测的离散微分算子，对噪声具有平滑作用，可以提供较为精确的边缘方向信息。
   
   C. Prewitt算子适合用来识别噪声较多、灰度渐变的图像
   
   D. Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系

4. 关于基于KNN机器视觉系统开发流程描述正确的有 :spoiler[**答案：ABC**] )

   A. KNN模型训练之前要提取合适的图像特征
   
   B. KNN是非参数学习算法，无显式训练过程
   
   C. 常见的图像特征包括SIFT特征、HOG特征、轮廓特征
   
   D. 一般KNN模型训练前不用对图片进行预处理操作

5. OpenCV中image的本质上是多维数组，可以利用numpy提供的shape函数得到矩阵的行数和列数，假设使用img = cv.imread("../lenA、png", cv.IMREAD_COLOR)读取一张512*512的彩色图像，则以下说法正确的有 :spoiler[**答案：ABCD**] )

   A. numpy.shape(img)[0]表示图像的高度
   
   B. img.shape[1]表示图像的宽度
   
   C. img.shape[2]表示图像的通道数，值为3
   
   D. img.shape的值是一个数组

6. 如果使用img = cv.imread("lenA、jpg", cv.IMREAD_COLOR)读取512*512大小的图像，则关于img说法正确的有 :spoiler[**答案：ABD**] )

   A. img[100,100,0]是获取图像（100,100）位置点的蓝色通道像素值
   
   B. img[100,100]是获取图像（100,100）位置点的三个通道的像素值
   
   C. img[100,100,1]是获取图像（100,100）位置点的蓝色通道像素值
   
   D. img[100,100,2]是获取图像（100,100）位置点的红色通道像素值

7. 使用torch创建卷积网络时，关于前向传播函数forward（self, x）说法正确的是 :spoiler[**答案：BCD**] )

   A. 前向传播和反向传播一样，都是用来更新网络的参数
   
   B. 前向传播的主要任务是根据输入数据计算神经网络的输出
   
   C. 神经网络训练完成后，前向传播函数用于进行推理，即给定一个输入，网络通过前向传播计算出预测结果
   
   D. 前向传播计算出的输出还会与实际标签对比，计算损失函数，然后用于反向传播来更新网络的参数

8. 以下各项描述正确的包括 :spoiler[**答案：BCD**] )

   A. 使用keypoints, descriptors = sift.detectAndCompute(img, None)对不同图片进行特征提取，返回值descriptors的长度都是一致的
   
   B. 使用features = features.reshape(1, -1)是将特征值展平为一行数组
   
   C. X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)进行训练集和测试集划分时，设置训练集的比例是0.25
   
   D. 使用svc = SVC(kernel='rbf', class_weight='balanced')创建支持向量机时，'rbf'是选取的核函数

9. 以下关于机器学习算法以下描述正确的包括 :spoiler[**答案：AC**] )

   A. 使用knn = KNeighborsClassifier(n_neighbors=N)创建knn模型，n_neighbors的取值N最大是训练样本集的数据总个数
   
   B. 对于一般检测任务，模型的准确率越高越好，F1值越低越好
   
   C. 对于SVC分类器clf，代码clf = clf.fit(X_train, y_train)中X_train表示是训练数据集
   
   D. 对于SVC分类器clf，代码y_pred = clf.predict(X_test)中y_pred是一个int值

10. 边缘检测的目的是标识数字图像中亮度变化明显的点，其应用场景包括 :spoiler[**答案：ABCD**] )

   A. 边缘检测是图像分割、目标区域识别和区域形状提前的重要基础

   B. 边缘包含图像有价值的边界信息，可以用于图像理解和分析，通过边缘检测可以极大降低后续图像分析和处理的数据量

   C. 边缘检测可用于航天航空领域处理图像质量较低的图像信息

   D. 边缘检测可用于交通管理中的视频监测、车辆识别

11. 机器视觉在工业上的典型应用场景包括 :spoiler[**答案：ABCD**] )

   A. 机器人取放零件

   B. 车牌识别

   C. 产品质量检测

   D. 自动抄表

12. 以下关于机器学习算法描述正确的是 :spoiler[**答案：ABD**] )

   A. 机器学习算法可以分为监督学习、无监督学习和强化学习三类

   B. 监督学习是通过已标记的训练数据来 train 模型

   C. 无监督学习是通过已标记的训练数据来 train 模型，以达到最大化累积奖励的目标

   D. 机器学习广泛应用于图像识别、自然语言处理和推荐系统等领域

13. 以下的关于图像形态学相关描述正确的是 :spoiler[**答案：BCD**] )

   A. 开运算等于对图像先进行膨胀，然后进行腐蚀，闭运算是相反的

   B. 腐蚀操作能够消融物体的边界，也可以用来消除无意义的孤立点

   C. 膨胀操作会使边界向外部扩张，可以用来填补目标物体中的空洞

   D. 利用数学形态学可以去除图像中的噪声点，提取图像轮廓

14. 以下哪些描述是SVM（支持向量机）的相关概念描述 :spoiler[**答案：ACD**] )

   A. 最大间隔分类器：能够将不同类别的样本点以最大间隔分开的超平面

   B. 权值共享：与图像进行局部连接的所有神经元使用同一组参数，即一个特征平面使用同一个卷积核内的参数

   C. 核函数是将原始特征映射到高维特征空间，从而使得非线性问题在高维空间中变为线性可分的问题

   D. 松弛变量用于衡量每个样本对于分类超平面的违背程度

15. 关于卷积神经网络以下说法不正确的是 :spoiler[**答案：ABD**] )

   A. 池化过程是用卷积核按照一定步长输入矩阵进行点积运算，将卷积结果输入激活函数得到矩阵称为特征图

   B. 卷积操作将语义上相似的特征合并起来，常取对应区域的最大值、平均值等

   C. LeNet-5和Alexnet都是卷积神经网络

   D. 为了快速调整卷积神经网络的参数，一般选择较大的学习率

16. 灰度变换是将原图像的灰度动态范围扩展到指定范围或整个动态范围，以下哪些方法可以实现灰度变换 :spoiler[**答案：ABCD**] )

   A. 分段线性变换

   B. 对数变换和反对数变换

   C. 幂律变换

   D. 直方图均衡化

17. 关于图像高斯滤波说法正确的是 :spoiler[**答案：ABCD**] )

   A. 开高斯滤波是一种线性平滑滤波，对于抑制服从正态分布的噪声非常有效

   B. 高斯滤波对图像邻域内像素进行平滑时，邻域内不同位置的像素被赋予不同的权值

   C. 高斯滤波对图像进行平滑的同时，同时能够更多的保留图像的总体灰度分布特征

   D. OpenCV中高斯滤波函数是GaussianBlur，参数包括输入原图、滤波核大小、标准差、线型等

18. 以下关于torch读取自定义数据集说法正确的包括 :spoiler[**答案：ABCD**] )

   A. 需要添加依赖from torch.utils.data import Dataset 

   B. 自定义数据集读取类需要重写__len__(self)函数

   C. 自定义数据集读取类需要重写__getitem__(self, idx)函数

   D. 继承Dataset的变量image_paths和labels是数组类型

19. 使用OpenCV进行图像分割的方法包含 :spoiler[**答案：ABCD**] )

   A. 固定阈值分割

   B. 自适应阈值分割

   C. grabCut算法分割

   D. floodFill漫水填充分割

20. 基于深度学习的运动目标检测主要有哪些常用模型 :spoiler[**答案：AB**] )

   A. YOLO网络

   B. SSD网络

   C. 支持向量机 

   D. K-Means

 

## 三、编程题

### 1. 注释补充代码。

import cv2

import numpy as np

img = cv2.imread("../lena.png", 1)

\# 彩色图像均衡化,需要分解通道 对每一个通道均衡化

(b, g, r) = cv2.split(img) 

bH = cv2.equalizeHist(b)

gH = cv2.equalizeHist(g)

\# 对红色通道进行均衡化

(1)  :spoiler[**答案：rH = cv2.equalizeHist(r)**]

\# 对三个通道进行合并，使用opencv的merge函数

(2)  :spoiler[**答案：img_equ = cv2.merge((bH, gH, rH))**]

\# 对图像img灰度转换

(3)  :spoiler[**答案：img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)**]

\# 在添加的边框后的图像上绘制矩形，从坐标（10,10）开始，到（100, 100）结束，颜色是绿色

(4)  :spoiler[**答案：cv2.rectangle(img, (10, 10), (100, 100), (0, 255, 0), 2)**]

cv2.waitKey(0)

\# 获取上一步返回图片的通道个数

(5)  :spoiler[**答案：channels = img.shape[2] if len(img.shape) == 3 else 1**]

### 2. 补充完成以下代码，实现图像缩放

import numpy as np

import cv2

 

\#缩放函数定义

def resizeImage(image, width=None, height=None, inter=cv2.INTER_AREA):

  newsize = (width,height)

\#获取图像尺寸，高度h，宽度w

(1)  :spoiler[**答案：h, w = image.shape[:2]**]

  if width is None and height is None:

​  	 return image

\#计算缩放比例

  if width is None:

​    n = height/float(h)

​    newsize = (int(n*w),height)

  else :

​    n = width/float(w)

​    newsize = (width,int(h*n))

\#使用opencv的resize函数缩放图像

(2)  :spoiler[**答案：resized = cv2.resize(image, newsize, interpolation=inter)**]

\# 返回缩放后图像

(3)  :spoiler[**答案：return resized**]

\#读取图片
imageOriginal = cv2.imread("../lena.png")

\#获取图像宽度和高度

(4)  :spoiler[**答案：h, w = imageOriginal.shape[:2]**]

\#调用缩放函数，将图像宽度和高度都增大2倍

(5)  :spoiler[**答案：resized_img = resizeImage(imageOriginal, width=w*2, height=h*2)**]



 

### 3. 假设数据集存储位置在当前目录imgs中，imgs目录下有10类数据，所在的文件夹名称是c1到c10，需要读取数据集并将其展平保存到数组中，然后进行训练集和测试集划分，划分测试集比例为30%。请根据以上要求和以下提示写出对应的代码。可使用伪代码表示。

代码结构提示：

import cv2

from numpy import *

from sklearn.model_selection import train_test_split,

import os, sys

def get_Image(img_path):

\#保存数据集

(1)  :spoiler[**答案：all_data_set = []**]

\#保存数据集对应的标签值

 (2)  :spoiler[**答案：all_data_label = []**]

\# 获取图片文件img_path下的图片分类文件夹c1到c10

 (3)  :spoiler[**答案：dirs = os.listdir(img_path)**]

\#循环读取图片文件夹c1-c10

(4)  :spoiler[**答案：for dir in dirs:**]

\#使用os.path.join构造图片所在的目录
  img_package = os.path.join(img_path, dir)
    
\#获取每个目录下图片的名称
  imgs = os.path.listdir(img_package)
    
\#循环读取图片

 (5)  :spoiler[**答案：for img in imgs:**]

   path = os.path.join(img_package, img)
    
\#读取图片

  (6)  :spoiler[**答案：img = cv2.imread(path)**]
    
\#灰度转换
  img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
  \# 获取图片高度和宽度

  (7)  :spoiler[**答案：h, w = img_gray.shape**]
    
  \# 将数据展平为h*w的一行数据

(8)  :spoiler[**答案：img_flat = img_gray.reshape(1, h*w)**]
    
  \# 保存图片到数据集合

 (9)  :spoiler[**答案：all_data_set.append(img_flat)**]
    
\# 保存数据集对应的标签值

(10)  :spoiler[**答案：all_data_label.append(dir)**]
    
  return all_data_set, all_data_label

 


PICTURE_PATH = "./imgs"  # PICTURE_PATH是图像数据集的父目录

all_data_set, all_data_label= get_Image(PICTURE_PATH)

\# 数据集转换为numpy数组

(11)  :spoiler[**答案：X = np.array(all_data_set)，y = np.array(all_data_label)**]     # 数据集转换为numpy数组和读图像对应的标签集

\# 划分数据，30%用于测试

(12)  :spoiler[**答案：X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)**]

 

### 4. 使用torch构造LeNet网络并完成人脸识别，根据以下内容提示完成卷积神经网络的代码补充或步骤描述。

import torch.nn

 

class LeNet(torch.nn.Module):

  def __init__(self, num_classes=1):

​    super(LeNet, self).__init__()

​         # 定义第一层卷积层

​    self.conv1 = torch.nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5)

​    self.pool1 = torch.nn.MaxPool2d(kernel_size=2, stride=2)

​         # 定义第二层卷积层，输入通道数6，输出通道数16，核大小是5

(1)  :spoiler[**答案：self.conv2 = torch.nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5)**]

   
​    self.pool2 = torch.nn.MaxPool2d(kernel_size=2, stride=2)

​         # 定义一个线性层，输入16*5*5，输出120个

​    self.fc1 = torch.nn.Linear(16*5*5, 120)

\# 定义一个线性层，输入120，输出84个

(2)  :spoiler[**答案：self.fc2 = torch.nn.Linear(120, 84)**]


​    self.fc3 = torch.nn.Linear(84, num_classes)

​    

def forward(self, x):

​    y = self.conv1(x)

​    y = torch.nn.functional.relu(y)

​    y = self.pool1(y)

​    y = torch.nn.functional.relu(y)

​    y = self.conv2(y)

​    y = self.pool2(y)

​    # 输入给全连接层需要展平数据，用torch.flatten函数

​   (3)  :spoiler[**答案：y = torch.flatten(y, 1)**]

​    y = self.fc1(y)

​    y = torch.nn.functional.relu(y)

​    # 请补充剩下代码，包括输入给第二个全连接层，第三个全连接层

​   (4)  :spoiler[**答案：y = self.fc2(y)，y = self.fc3(y)**]


  return y

 


\# 初始化lenet实例，类别为10

(6)  :spoiler[**答案：lenet = LeNet(num_classes=10)**]    

\# 自定义数据集读取类

import torch

import torchvision.transforms as transforms

from torch.utils.data import Dataset, DataLoader

class CustomDataset(Dataset):

  \# 请描述自定义数据集读取类需要重写的函数，描述每个函数的作用，文字描述

(7)  :spoiler[**答案：__len__(self): 返回数据集的大小，  __getitem__(self, idx): 返回索引idx对应的数据和标签**]


\# 构造图片数组和标签值数组

*（代码省略）*

\# 开始模型训练

transform = transforms.Compose([

\# 请描述输入给模型前必须要进行的处理操作，文字描述即可

(9)  :spoiler[**答案：将图像转换为张量，并进行归一化处理**]


dataloaderTrain = DataLoader(trainDataset, batch_size=8, shuffle=True) # 训练集读取

dataloaderTest = DataLoader(testDataset, batch_size=2, shuffle=True)    # 测试集读取

opt = torch.optim.SGD(lenet.parameters(), lr=0.01, momentum=0.9)      # 定义优化器

for epoch in range(10):

  \# 开始训练lenet模型，写出代码

(10)  :spoiler[**答案：lenet.train()**]

   for inputs, labels in dataloaderTrain:

​     # 描述模型训练必要过程
(11)  
:spoiler[**答案：optimizer.zero_grad()**]

:spoiler[**答案：outputs = lenet(inputs)**]

:spoiler[**答案：loss = criterion(outputs, labels)**]

:spoiler[**答案：loss.backward()**]

:spoiler[**答案：optimizer.step()**]


​    lenet.eval() # 开始评估

​    # 描述模型评估必要过程

(16)  
:spoiler[**答案：with torch.no_grad():**]

:spoiler[**答案：outputs = lenet(inputs)**]

:spoiler[**答案：loss = criterion(outputs, labels)**]


​     torch.save(lenet.state_dict(), "face_rec.pth")

 

### 5. 完成图片的灰度图直方图均衡化和图像分割代码，根据注释补充代码。

import cv2

import numpy as np

 

img = cv2.imread("../lena.png", 1)

\# 图像灰度转换

(1)  :spoiler[**答案：img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)**]

\# 对灰度图进行均衡化

(2)  :spoiler[**答案：img_eq = cv2.equalizeHist(img_gray)**]

\# 阈值分割，使用自动化分割，使用threshold函数，参数是cv2.THRESH_OTSU

(3)     :spoiler[**答案：ret, thresh = cv2.threshold(img_eq, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)**]

\# 获取图像尺寸，高度h，宽度w

(4)     :spoiler[**答案：h, w = img.shape[:2]**]

\# 将图像大小设置为原高度、宽度的1/2 

(5)     :spoiler[**答案：img_resized = cv2.resize(img, (w//2, h//2))**]

 

### 6. 根据注释提示完成图像翻转和滤波的代码

import numpy as np

import cv2 

 

img = cv2.imread('../../lena.png', 1)

\# 获取图像img的宽rows，高cols，通道数channels

(1)  :spoiler[**答案：rows, cols, channels = img.shape**]

gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

\# 对灰度图像水平翻转，使用flip函数，水平翻转代码flipCode=1

(2)  :spoiler[**答案：flipped_img = cv2.flip(gray_img, 1)**]

\# 对翻转后的图像进行高斯滤波，滤波核大小为3，标准差设为5

(3)  :spoiler[**答案：blurred_img = cv2.GaussianBlur(flipped_img, (3, 3), 5)**]

\# 使用OpenCV的getStructuringElement获取矩形结构元，大小（3,3）

kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))

\# 使用OpenCV的morphologyEx求梯度，参数MORPH_GRADIENT，返回结果dst1

(4)  :spoiler[**答案：dst1 = cv2.morphologyEx(blurred_img, cv.MORPH_GRADIENT, kernel)**]

\# 用MORPH_OPEN参数求开运算操作

(5)     :spoiler[**答案：dst2 = cv2.morphologyEx(dst1, cv.MORPH_OPEN, kernel)**]

\# 显示处理结果图像

cv.imshow('dst', dst2)

cv.waitKey(0)

cv.destroyAllWindows()

 

### 7. 请使用paddlepaddle构造lenet5模型，按照提示完成下面代码填写。

\# 定义 LeNet 网络结构

class LeNet(paddle.nn.Layer):

  def __init__(self, num_classes=1):

​    super(LeNet, self).__init__()

​    # 创建第1个卷积层

(1)  :spoiler[**答案：self.conv1 = Conv2D(in_channels=1, out_channels=6, kernel_size=5)**]

\# 创建池化层1

(2)  :spoiler[**答案：self.max_pool1 = MaxPool2D(kernel_size=2, stride=2)**]

​    # 尺寸的逻辑：池化层未改变通道数；当前通道数为6

​    # 创建第2个卷积层

(1)  :spoiler[**答案：self.conv2 = Conv2D(in_channels=6, out_channels=16, kernel_size=5)**]

\# 创建第2个池化层

(2)  :spoiler[**答案：self.max_pool2 = MaxPool2D(kernel_size=2, stride=2)**]

​    # 创建第3个卷积层

self.conv3 = Conv2D(in_channels=16, out_channels=120, kernel_size=4)

​    # 尺寸的逻辑：输入层将数据拉平[B,C,H,W] -> [B,C*H*W]

​    # 输入size是[28,28]，经过三次卷积和两次池化之后，C*H*W等于120

​    self.fc1 = Linear(in_features=120, out_features=64) 
​    \# 创建全连接层，第一个全连接层的输出神经元个数为64， 第二个全连接层输出神经元个数为分类标签的类别数

(3)  :spoiler[**答案：self.fc2 = Linear(in_features=64, out_features=num_classes)**]

 
  \# 网络的前向计算过程

  def forward(self, x):

​    x = self.conv1(x) 

​    # 每个卷积层使用Sigmoid激活函数，后面跟着一个2x2的池化

​    x = F.sigmoid(x) 

​         # 将x输入给池化层1

(3)  :spoiler[**答案：x = self.max_pool1(x)**]

​    x = F.sigmoid(x)

​    x = self.conv2(x) 

​    x = self.max_pool2(x)

​    x = self.conv3(x) 

​    # 尺寸的逻辑：输入层将数据拉平[B,C,H,W] -> [B,C*H*W]

(4) 
:spoiler[**答案：x = paddle.flatten(x, start_axis=1, stop_axis=-1)**]

:spoiler[**答案：x = self.fc1(x)**]

:spoiler[**答案：x = F.sigmoid(x)**]

:spoiler[**答案：x = self.fc2(x)**]

:spoiler[**答案：return x**]

 

### 8. 请根据以下提示完成使用SVM做图像分类的代码补充或步骤描述。

\# 使用时间依赖包用于计算训练时间

from time import time 

import cv2

from numpy import *

\# 描述train_test_split和GridSearchCV的作用

 (1)  :spoiler[**答案：train_test_split用于将数据集划分为训练集和测试集，可以指定划分比例和随机种子；GridSearchCV用于超参数调优，通过交叉验证来寻找最优参数组合。**]

from sklearn.model_selection import train_test_split, GridSearchCV

from sklearn.metrics import classification_report, confusion_matrix

from sklearn.decomposition import PCA

from sklearn.svm import SVC

\# 读取数据集和标签集，

def get_Image(img_path):

  all_data_set = [] # 保存数据集

  all_data_label = [] # 保存数据集对应的标签值

  dirs = os.listdir(img_path)

for dir in dirs:

img_dir = os.path.join(img_path, dir)

​    imgs = os.listdir(img_dir)

​    for img in imgs:

path = os.path.join(img_dir, img)

​        img = cv2.imread(path)

​        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

​        h, w = img_gray.shape

\# 将图像数据展平为一行数组

(1)  :spoiler[**答案：img_flat = img_gray.reshape(h*w)**]

\# 保存图片到数据集合

(2)  :spoiler[**答案：all_data_set.append(img_flat)**]

\# 保存数据集对应的标签值，标签值用dir表示

(3)  :spoiler[**答案：all_data_label.append(dir)**]

return all_data_set, all_data_label, h, w

\# PICTURE_PATH是图像数据集的父目录

PICTURE_PATH = "./data/jpg" 

all_data_set, all_data_label, h, w = get_Image(PICTURE_PATH)

\# 获取图像数据集数组

X = numpy.array(all_data_set)   

\# 读图像对应的标签集

y =numpy. array(all_data_label) 

n_samples, n_features = X.shape # 获取的是行数（样本数）和列数（特征数）

\# 划分数据集，3/4用于训练，1/4用于测试

(4)  :spoiler[**答案：X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)**]

\# 创建PCA实例进行数据降维

(5)  :spoiler[**答案：pca = PCA(n_components=150, svd_solver='randomized', whiten=True).fit(X_train)**]

\# 得到训练集投影系数，即进行特征转换

X_train_pca = pca.transform(X_train)

\# 得到测试集投影系数X_test_pca

(6)  :spoiler[**答案：X_test_pca = pca.transform(X_test)**]

\# 创建SVC分类器

svc = SVC(kernel='rbf', class_weight='balanced')

param_grid = {'C': [1e3, 5e3, 1e4, 5e4, 1e5], 'gamma': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.1], }

clf = GridSearchCV(svc, param_grid)

\# 开始训练

(7)  :spoiler[**答案：clf = clf.fit(X_train_pca, y_train)**]

import joblib

\# 保存svm模型

joblib.dump(clf, 'svm_model.joblib')

\# 加载模型

clf_loaded = joblib.load('svm_model.joblib')

\# 调用模型clf_loaded的predict接口，传入测试集数据

(8)  :spoiler[**答案：y_pred = clf_loaded.predict(X_test_pca)**]

\# 描述如何调用模型完成多张图片推理，文字描述

(9)  :spoiler[**答案：将多张图片预处理成相同的格式和尺寸，然后批量输入到模型中进行预测，可以通过循环处理或构建批处理数据集来实现。**]

\# 描述如何调用模型完成多张图片推理，文字描述

(10)  :spoiler[**答案：将多张图片预处理成相同的格式和尺寸，然后批量输入到模型中进行预测，可以通过循环处理或构建批处理数据集来实现。**]
